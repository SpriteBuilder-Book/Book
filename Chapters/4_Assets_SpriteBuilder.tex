\chapter{A Game with Assets in SpriteBuilder}

Graphics and Sounds are the essence of every good game. In the first chapter you
have learned the very basics of \SB{} and \cocos{} by building a game that only
uses plain colored shapes. In this chapter you will learn how \SB{} helps you to
integrate assets into your game. Learning by example is the most fun, so we will
build a small game throughout this chapter that uses all aspects of asset
management. 

\section{Adding Assets to a SpriteBuilder project}
Start by creating a new \SB{} project for this game. I have called the
project \textit{FallingObjects}.

Now you should download the assets from
\url{https://dl.dropboxusercontent.com/u/13528538/SpriteBuilderBook/assets.zip}.
Once the download completes you add the assets to the project by dragging the
entire folder into the left \textit{File View} in the left panel of
\SB{}:\index{Assets!Adding Assets}

\begin{figure}[H]
		\centering
		\includegraphics[width=200pt]{images/Chapter2/DragAssets.png}
\end{figure}

Great, now we have some assets to use in our game. Now is a good time to take a
close look at how \SB{} and \cocos{} handle assets.

\section{Asset Handling in \SB{} and \cocos{}}
One of the main goals of \SB{} is to make game development for multiple device
types as easy as possible. This means that games should automatically be able to
run on differently sized iPhones, iPads and Android Devices. Since each of these
devices has a different resolution \cocos{} and \SB{} allow developers to use different assets to target them. \SB{}
provides four different resolution categories:
\begin{description}
\item[phone] resolution for non-retina iPhone and Android devices
\item[phone-hd] retina resolution for iPhone and Android
\item[tablet] resolution for non-retina iPad and Android tablets
\item[tablet-hd] resolution for retina iPad and Android tablets
\end{description}

Luckily using \SB{}, there is no need to provide four resolutions for each asset
thanks to \textbf{automatic downscaling}\index{Assets!Automatic Downscaling}.
Per default \SB{} assumes that all assets added to a project are provided in \textit{tablet-hd} resolution, then
\SB{} generates downscaled images for the other resolutions. While you can
provide different images for four targets, \SB{} only knows three resolution
types:
\begin{description}
\item[1x] non-retina images
\item[2x] retina images
\item[4x] double sized retina images
\end{description}

By default \SB{} maps these resolution types to the different devices in a way
that every asset has the same size (in relation to the screen size) on every
device. This means games running on an iPad will look very similar to games
running on an iPhone, except that the have a slightly different aspect ratio.
Here is an example from on of our tutorials showing what a game looks like on
different device types:

\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{images/Chapter2/ResultsFlexibleScaleMode.png}
		\caption{From our tutorial \textit{Dynamic Layouts with SpriteBuilder and
		Cocos2D}}
\end{figure}

Let's take a look at where all the settings I mentioned are visible in the \SB{}
UI. When you open the project settings (\textit{File -> Project Settings\ldots})
you can see the available downscaling options:

\begin{figure}[H]
		\centering
		\includegraphics[width=300pt]{images/Chapter2/DownScalingGlobal.png}
\end{figure}

This setting defines the \textit{global} downscaling option. Individual assets
can define their own behaviour, thereby overriding this global setting. To make
support of multiple devices as easy as possible you should provide all of your
assets in \textit{4x} resolution and keep this default setting.

When you select an individual asset from the File View you can see different
downscaling settings:

\begin{figure}[H]
		\centering
		\includegraphics[height=200pt]{images/Chapter2/DownScalingPerAsset.png}
\end{figure}

Each asset can have its own \textit{Scale from} setting. \textit{Default} means
that the global project setting applies (in this project: downscaling from
\textit{4x}). Additionally you can see how the different resolution types are
mapped to the different device types. Here you could for example choose that a
certain asset should not be scaled up on retina tablets by choosing a
\textit{2x} resolution for \textit{tablethd} - however, the default settings
work best most of the time.

For future reference, this is an example that shows you which sizes your assets
will have on the different devices by default:

\begin{table}[H]
\begin{tabular}{llll}
\textbf{Device} & \textbf{Default Resolution Type} & \textbf{Size on Screen (points)} & \textbf{Size in Pixels} \\
iPhone          & 1x                               & 50x50                            & 50x50                   \\
iPhone Retina   & 2x                               & 50x50                            & 100x100                 \\
iPad            & 2x                               & 100x100                          & 100x100                 \\
iPad Retina     & 4x                               & 100x100                          & 200x200                
\end{tabular}
\end{table}

You can see, if you have a size in mind for a certain asset on an iPhone you
should provide the asset in four times larger resolution.

A last interesting case are background images that you want to work for
all 4 resolutions. A solution is discussed in
the Q\&A section (\ref{background_all_resolutions}).

\begin{details}[frametitle={Different images for different devices}] 
You can not only change the scaling option for an asset on different devices,
you can even use an entirely different image for a certain resolution. You can
do that by dragging an image \textbf{that is currently not part of the \SB{}
project} from Finder into one of the four boxes below the asset preview:
%TODO: note this fact in docs as well
%TODO: ask viktor why this displays the image for tablet and not for phone in SB
\begin{figure}[H]
		\centering
		\includegraphics[height=140pt]{images/Chapter2/DifferentImageDevice.png}
\end{figure}

Note that images you add this way will be displayed in exactly the size you have
added them and will not be downscaled.

\end{details}

\begin{details}[frametitle={Behind the scenes}] 
If you are interested in how \SB{} and \cocos{} organize assets you can take a
look at the resource package
(\textit{/Packages/\allowbreak{}SpriteBuilder Resources\allowbreak{}.sbpack}) by
right-clicking and selecting \textit{Show Package Contents}:
\begin{figure}[H]
		\centering
		\includegraphics[width=280pt]{images/Chapter2/behindscenes_resourcepack.png}
\end{figure}
You will see that \SB{} groups images inside the assets folder into a
\textit{resources-auto} folder, all images in that folder are subject to
automatic downscaling. If you explicitly add images for a certain resolution as
shown with the carrot in the above example, a new folder for that resolution
(e.g. \textit{resources-phonehd}) is created.

In \cocos{} a class called \inlinecode{CCFileUtils} is responsible for loading
the correct images for the current device during runtime. \SB{} uses a special
configuration of \inlinecode{CCFileUtils} that is set up in
\inlinecode{[CCBReader configureCCFileUtils]}. \index{Framework
Classes!CCFileUtils}
\end{details}

\section{Adding the background image}
Now that we have a basic understanding of how asset management works, lets get
started working on our game. For now our game will only consist of one scene, so
we can start working in the \textit{MainScene.ccb} that is part of the \SB{}
template. First, remove the existing content so that we can start with a blank
scene. Now we can add the background image. To add a sprite to a scene we can
simply drag the asset to the stage, \SB{} will automatically create an instance
of \ccsprite{}. Add the \textit{background.png} image to the stage.

How should we position this background image? We already have briefly discussed
the \SB{} positioning system (\ref{PositioningSystem}). Using the positioning
system correctly is especially important when we create games for phones and tablets -
which we always should try to do. In most cases - like in this game it is the
best to center the background image. That way phones and tablets will display a
very similar portion of the background image. You can center the image by
choosing a \textit{normalized} position type (\textit{in \% of parent
container}) and setting the position to (50, 50).

\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{images/Chapter2/center_background.png}
\end{figure}

You can preview what your game will look like on different device types directly
in \SB{}, without the need to compile and run the game - you should do this as
often as possible! The option is available from the menu \textit{Document ->
Resolution}. You can also use the CMD+1, CMD+2 and CMD+3 shortcuts. This feature
will allow you to preview the game on a 3.5-inch iPhone, a 4-inch iPhone and an
iPad.

\section{Create falling objects}
Now let's dive into the implementation of the actual game. The next step should
be adding falling objects. Our game will have two categories of objects, ones
that should be caught (food) and ones that shouldn't (electronic devices).

In total we have over ten different objects in our game but these just exist as
visual enhancement, actually we are only differing between two types of objects.
One way to implement the falling objects would be creating a \ccbfile{} for each
object but that isn't actually necessary for this game. We need to create all
falling objects dynamically, while the game is running, and for each object we
only need to store if it should be caught or not. That can be best accomplished
by a subclass of \ccsprite{} that we create in code. This way you will also
learn how to use assets you added in \SB{} to create \ccsprite{}s in code.
Open the \xcode{} project of the game to get started.

\subsection{Create a falling object class}
In general we have two ways to differentiate objects a player should catch and
ones he shouldn't catch. We could:
\begin{itemize}
  \item Create two distinct subclasses of \ccsprite{}, each representing one
  type of object
  \item Only have one subclass and add a \inlinecode{type} property to it
\end{itemize}
Since our falling objects won't have any type-specific behaviour, creating two
distinct subclasses is not necessary in this case. Instead, as of now, one
subclass with a \inlinecode{type} property is the better solution.

Create a new class called \inlinecode{SBBFallingObject} and make it a subclass
of \ccsprite{}. The best way to represent different types in Objective-C is
using enumerations. Add this enum definition to \textit{SSBFallingObject.h},
above the \inlinecode{@interface} block:

\begin{lstlisting}
typedef NS_ENUM(NSInteger, SBBFallingObjectType) {
    SBBFallingObjectTypeGood,
    SBBFallingObjectTypeBad
};
\end{lstlisting}

%TODO: figure out if ther is any decent way to force other classes to only use
% the initializer of this subclass
Additionally we add a property to store the type and an initializer that allows
us to create falling objects with a certain type. Your complete \textit{.h} file
should look similar to this:

\begin{lstlisting}
#import "CCSprite.h"

typedef NS_ENUM(NSInteger, SBBFallingObjectType) {
    SBBFallingObjectTypeGood,
    SBBFallingObjectTypeBad
};

@interface SBBFallingObject : CCSprite

@property (nonatomic, readonly) SBBFallingObjectType type;

- (id)initWithType:(SBBFallingObjectType)fallingObjectType;

@end
\end{lstlisting}

We define the property to be \textit{readonly} because will not support changing
the type of a falling object after it has been created.

\subsection{Choose an asset for a falling object}
We want the game to spawn entirely random falling objects. As you remember we
have a couple of assets for both types of objects. Whenever we spawn an object
we will need to choose a random asset, based on the object type. A good place to
implement this functionality is directly in the \inlinecode{SBBFallingObject}
class. When \inlinecode{initWithType:} gets called we choose a random asset and
apply it as a texture to the \inlinecode{SBBFallingObject}.

How can we know which assets we have available and which of them represent
objects that we should catch and that we shouldn't? One way of implementing this
would be creating two arrays, one for each object type, and storing filenames
for different assets in these arrays. As good game developers however, we try to
keep game content and code as separated as possible. That makes it easier to
update the list of assets later on and it keeps our codebase small and well
structured. So instead of creating these arrays in code we could use some sort
of resources file that stores information on available images. A very common format for storing such type of information in Cocoa Touch is a \textit{plist} (Property List). You can create a
\textit{plist} by selecting \textit{File -> New -> File\ldots} from \xcode{}s
menu. Then you need to select \textit{Resource} from the left panel and choose
\textit{Property List} on the right:

\begin{figure}[H]
		\centering
		\includegraphics[width=300pt]{images/Chapter2/create_plist.png}
\end{figure}

As the name choose \textit{SBBFallingObjectImages}. Now fill the \textit{plist}
with two arrays that contain the filenames of the assets that we added in \SB{}.
When accessing assets from a \SB{} project you always need to include folder
names. Instead of referencing the tomato with \inlinecode{tomato.png} you need
to use \inlinecode{assets/tomato.png} since the asset is in the
\inlinecode{assets} folder in the \SB{} project:

\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{images/Chapter2/plist_setup.png}
\end{figure}
Now we have a list of all asset names grouped into the two object type
categories. Time to implement the \inlinecode{SBBFallingObject} class.

When a falling object is initialized we want to
choose random image from the \textit{plist} that we just created.
The first step is loading the \textit{plist} in code. Luckily \textit{plists}
consist of Dictionaries, Arrays, Strings, etc. and all of these types exist in
Objective-C as well - there are some very convenient methods to load
\textit{plists} in code. During each game the player plays we are going to create hundreds of
falling objects. Since the images that represent these objects won't change it
would be a waste of resources to load the \textit{plist} every time we create a
new instance of \inlinecode{SBBFallingObject}. Instead we should only load it
once and then keep a reference to it for future use. We can create
\inlinecode{static} variables to hold the content of the \textit{plist} once it
is loaded. 

\begin{details}[frametitle={Static variables in Objective-C}] 
In Objective-C the concept of class variables does not exist but the C-keyword
\inlinecode{static} makes a variable only accessible from the file it is
defined in. Therefore defining a \inlinecode{static} variable in a \textit{.m}
file is very similar to a class variable.
\end{details}

We can then override the class method \inlinecode{initialize} to load the
\textit{plist} and store the results in the \inlinecode{static} variables. The
\inlinecode{initialize} method is only called once per class and is guaranteed
to be called before the class is used, so this is the perfect place to do some
class level preparation work.

Open \textit{SBBFallingObject.m} to start implementing
this. First, define to \inlinecode{static} array references:
\begin{lstlisting}
static NSArray *fallingObjectTypeGoodImageNames;
static NSArray *fallingObjectTypeBadImageNames;
\end{lstlisting}
Then implement the \inlinecode{initialize} method to create two arrays and
assign them to these variables:
\begin{lstlisting}
+ (void)initialize {
  // load possible images from plist
  NSURL *plistURL = [[NSBundle mainBundle] URLForResource:@"SBBFallingObjectImages" withExtension:@"plist"];
  NSDictionary *fallingObjectImageNames = [NSDictionary dictionaryWithContentsOfURL:plistURL];
  fallingObjectTypeGoodImageNames = fallingObjectImageNames[@"FallingObjectTypeGoodImages"];
  fallingObjectTypeBadImageNames = fallingObjectImageNames[@"FallingObjectTypeBadImages"];
}
\end{lstlisting}
First we need to get the path to the \textit{plist}. Then we can load the
\textit{plist} using a convenience method of \inlinecode{NSDictionary}, this is
possible because the root object in our \textit{plist} is a dictionary. From
that dictionary we can extract the two arrays with the images for good objects
and bad objects and assign them to our \inlinecode{static} variables. When the
\inlinecode{SBBFallingObject} class is used the first them this code will run
and set up the two arrays for us!

Now that we have access to the image names we can implement the actual
initializer of \inlinecode{SBBFallingObject}. We need to:
\begin{itemize}
  \item Pick a random image based on the object type
  \item Call the \inlinecode{initWithImageNamed:} of \ccsprite{}
\end{itemize}

This is what the initializer should look like:
\begin{lstlisting}
- (id)initWithType:(SBBFallingObjectType)fallingObjectType {
  // pick a random image name based on the FallingObjectType chosen
  NSString *imageName = nil;
  
  if (fallingObjectType == SBBFallingObjectTypeGood) {
    int randomImageIndex = arc4random_uniform((int)[fallingObjectTypeGoodImageNames count]);
    imageName = fallingObjectTypeGoodImageNames[randomImageIndex];
  } else if (fallingObjectType == SBBFallingObjectTypeBad) {
    int randomImageIndex = arc4random_uniform((int)[fallingObjectTypeBadImageNames count]);
    imageName = fallingObjectTypeBadImageNames[randomImageIndex];
  }
  
  // call super initializer with selected image
  self = [super initWithImageNamed:imageName];
  
  if (self) {
    self.anchorPoint = ccp(0, 0);
    _type = fallingObjectType;
  }
  
  return self;
}
\end{lstlisting}
Overall a prety straightforward method. We first check which type of object we
are initializing. Based on the type we pick one of the arrays that have been
populated with the content from the \textit{plist}. Then we pick a random
element from that array. That random element is our file name, we pass that on
to the \ccsprite{} initializer \inlinecode{initWithImageNamed:}. The we
initialize two values. We set the \inlinecode{anchorPoint} of the
\inlinecode{SBBFallingObject} to the bottom left corner, that will make it
easier to determine the spawn position later on. Additionally we store the
object type that has been passed in as a parameter to the initializer.
That's all we need in order to use \inlinecode{SBBFallingObject}! Now we can
move on and spawn some objects.

\begin{details}[frametitle={Accessing properties
in initializers}] In Objective-C it is common to access properties in initializers through their
instance variables. The goal is to avoid potential side effects that could
occur by calling setter/getter methods in the class itself or in subclasses
while the object is not entirely initialized yet.
\end{details}

\section{Spawn falling objects}
Now it's time to implement one of the core mechanics of the game: Spawning
objects and make them fall from the top of the screen to the bottom. We are
going to implement this in \textit{SBBMainScene.m}. Since we will be using the
\inlinecode{SBBFallingObject} class, start by adding an \inlinecode{import}
statement:

\begin{lstlisting}
#import "SBBFallingObject.h"
\end{lstlisting}

We will spawn objects after a certain time period. The spawning objects will
start at the top of the screen and fall to the bottom. To not use an
increasingly amount of memory we will need to take care to remove objects that
have fallen below the bottom edge of the screen. A good way to do this is
creating an array to store all the objects we spawn. Add the array definition to
the private interface of the class in \textit{SBBMainScene.m}:

\begin{lstlisting}
@interface SBBMainScene()

@property (nonatomic, strong) NSMutableArray *fallingObjects;

@end
\end{lstlisting}

We need to define a falling speed and an interval at which we want to spawn
objects. A good way to do this is by defining constants - we want to avoid to
have these numbers all over our code. Let's create two constants at the top of
the file:

\begin{lstlisting}
static const CGFloat kFallingSpeed = 100.f;
static const CGFloat kSpawnFrequency = 0.5f;
\end{lstlisting}

\begin{details}[frametitle={Naming constants in Objective-C}] A common way to
name constants in Objective-C is using a leading small \textit{k}
for private constants (e.g. \inlinecode{kFallingSpeed}) and using the class name
as prefix for public constants which are declared in the \textit{.h} file (e.g.
\inlinecode{SBBFalling\allowbreak{}Object\allowbreak{}Falling\allowbreak{}Speed}.
\end{details}

In the \inlinecode{init} method we need to initialize our array of falling
objects:

\begin{lstlisting}
- (id)init {
    self = [super init];
    
    if (self) {
        _fallingObjects = [NSMutableArray array];
    }
    
    return self;
}
\end{lstlisting}

We are going to spawn falling objects with the frequency that we have defined in
the constant \inlinecode{kSpawnFrequency}. Through the \inlinecode{CCNode} class
\cocos{} provides convenient methods for scheduling repeating events without the
need to instantiate a timer. We schedule that timer in the
\inlinecode{onEnterTransitionDidFinish} method:

\begin{lstlisting}
- (void)onEnterTransitionDidFinish {
    [super onEnterTransitionDidFinish];
    
    // spawn objects with defined frequency
    [self schedule:@selector(spawnObject) interval:kSpawnFrequency];
}
\end{lstlisting}

All we need to provide is a \textit{selector}, which simply means a method
name, and a frequency at which it shall be called. Now, as soon as the
\inlinecode{SBBMainScene} is presented on the stage, the
\inlinecode{spawnObject} method will be called twice a second.
To complete the spawning functionality we will have to implement the
\inlinecode{spawnObject} method and additionally move the spawned objects from
the top of the screen to the bottom.

We want to randomly spawn either positive objects that should be caught or
negative ones that should not, for that we will generate a random number. Based
on the random number we will generate a falling object. We will place that
spawning object just above the screen at a random X position. Here is how we can
implement that:

\begin{lstlisting}
- (void)spawnObject {
    // generate a random number to decide wether to spawn a positive or a negative object
    NSInteger randomNumber = arc4random_uniform(2);

    SBBFallingObject *fallingObject = nil;
    
    if (randomNumber == 0) {
        fallingObject = [[SBBFallingObject alloc] initWithType:SBBFallingObjectTypeBad];
    } else if (randomNumber == 1) {
        fallingObject = [[SBBFallingObject alloc] initWithType:SBBFallingObjectTypeGood];
    }
    
    // add all spawning objects to an array
    [self.fallingObjects addObject:fallingObject];
    // spawn all obejcts at top of screen and at a random x position with scene bounds
    CGFloat xSpawnRange = ( (CGFloat) self.contentSizeInPoints.width) - CGRectGetMaxX(fallingObject.boundingBox);
    CGPoint spawnPosition = ccp(arc4random_uniform(xSpawnRange), self.contentSizeInPoints.height);
    fallingObject.position = spawnPosition;
    [self addChild:fallingObject];
}
\end{lstlisting}

This is a schematic diagram of where we are spawning objects with the code shown
above:

\begin{figure}[H]
		\centering
		\includegraphics[width=200pt]{images/Chapter2/SpawnObjects.png}
\end{figure}

Our current version of the game spawns new objects twice a second at the top of
the screen and at a random X position. However, these objects don't move yet so
you won't be able to see them falling down. Let's implement the falling code to
complete the entire spawning functionality!

\section{Move falling objects}
The last step for this chapter will be moving the objects we are spawning to the
bottom of the screen. While building your very first \SB{} game you have learned
to use the \cocos{} action system to move nodes. The action system lets us
describe changes over time, e.g. \textit{move 100 points to the right over 2
seconds}. Another option to move nodes that we haven't
discussed yet is using the \cocos{} \textit{update loop}\index{Update Loop}.

\subsection{Update Loop}
When we build games with \cocos{} the engine attempts to render 60 frames a
second and draws theses rendered frames to the screen of the device. When we
move objects between rendering frames, they will appear as moving objects to the
user. \cocos{} provides a method that is called directly before a frame is
rendered, the \inlinecode{update} method.

The \inlinecode{update} method is defined as part of the
\inlinecode{CCSchedulerTarget}\index{Framework Classes|CCSchedulerTarget}
protocol. \inlinecode{CCNode} implements this protocol, that means any subclass
of \inlinecode{CCNode} can override the method. This is the signature of the
\inlinecode{update} method:
\begin{lstlisting}
- (void)update:(CCTime)delta
\end{lstlisting}
We receive one parameter called \inlinecode{delta} from the \cocos{} framework.
The delta parameter contains the milliseconds since the \inlinecode{update}
method was called last. Most of the time this value will be \textit{0.0167}
milliseconds, which is 1/60 of a second. If the performance of our game drops
below 60 FPS this value will be higher, because the time between two rendered
frames will increase. If we want our objects to move at the same speed,
independent of the current framerate, we can use this delta parameter to
calculate how far we need to move nodes between two given frames.

Enough of the theory - let's implement our update method, that will help you
understand the details.

\subsection{Implementing the update method}
Here is what we want to do in the update method:

\begin{itemize}
  \item Iterate over all falling objects
  \item For each object check if it is within the screen boundaries
  \item If the object is outside of the screen, remove it
  \item If the object is inside of the screen boundary, let it fall to the
  bottom
\end{itemize}

And here is how we can implement it:

\begin{lstlisting}
- (void)update:(CCTime)delta {
    // use classic for loop so that we can remove objects while iterating over the array    
    for (int i=0; i < [self.fallingObjects count]; i++) {
        SBBFallingObject *fallingObject = self.fallingObjects[i];
        
        // check if falling object is below the screen boundary
        if (CGRectGetMaxY(fallingObject.boundingBox) < CGRectGetMinY(self.boundingBox)) {
            // if object is below screen, remove it
            [fallingObject removeFromParent];
            [self.fallingObjects removeObject:fallingObject];
        } else {
            // else, let the object fall with a constant speed
            fallingObject.position = ccp(fallingObject.position.x, fallingObject.position.y - (kFallingSpeed * delta));
        }
    }
}
\end{lstlisting}

The interesting aspect of the code snippet above is how we check if the
falling object is out of bounds and how we move the falling object. Note that we
are using the \inlinecode{CGRectGetMaxY} and \inlinecode{CGRectGetMinY}
functions to determine the top and the bottom of the bounding boxes of the
falling object and the gameplay scene. The \inlinecode{CGRectGetMaxY} function
returns the largest Y value of the bounding box. Using these functions is preferred over accessing values
directly (e.g. \inlinecode{fallingObject.boundingBox.origin.y}) because they
also work for rectangles with negative sizes.

If we detect that the top border of the falling object is below the bottom
border of the screen, we remove the falling object from the scene.

If the falling object is within the screen boundary we move it to the bottom
with the constant speed that we defined earlier.

Now the falling mechanic is entirely implemented! In the next and last
subchapter you will learn how to add sound assets to the game.

\begin{details}[frametitle={Update vs. Fixed Update}] 
This chapter discusses the \inlinecode{update:} method of \cocos{} in detail.
\cocos{} provides a second similar method called
\inlinecode{fixedUpdate:}\index{Fixed Update}.
Unlike the \inlinecode{update:} method, the \inlinecode{fixedUpdate:} method is
\textbf{guaranteed} to be called at a specified interval (per default 1/60) and
is not dependent on the framerate the game is running at. The physics engine
integrated in \cocos{} uses the
\inlinecode{fixedUpdate:} method to perform all of its calculations. For you as
developer that means that you should implement code that changes physical
attributes in the \inlinecode{fixedUpdate:} method and \textbf{not} in the
\inlinecode{update:} method. We will discuss the physics engine of \cocos{} in
later chapters in detail. A nice blog post about the \inlinecode{fixedUpdate}
method is available here:
\url{http://kirillmuzykov.com/update-vs-fixedupdate-in-cocos2d/}.
\end{details}

\section{Play sound}
The goal of this chapter is that you learn how to use assets with \SB{} and
\cocos{}. Obviously images are the most important assets in games, but sound
effects also play a big role in creating game that your players enjoy. In this
section you will learn how to add a sound effect that gets played whenever one
of the falling objects drops out of the screen.

Start by downloading the sound file here:
\url{https://dl.dropboxusercontent.com/u/13528538/SpriteBuilderBook/drop.wav}.

All sound files need to be added to your \SB{} project in the \textit{Wave}
format. \SB{} will then generate compressed versions of that sound in different
formats for the iOS and the Android app.

\section{Exercises}
\subsection{Play the 'drop' sound from Code instead of using a timeline
animation}
