\chapter{User Interaction and Collision Detection}

In this chapter you will incorporate User Interaction into the object catching
game. The first step will be implementing a drag and drop mechanism that lets
the user move the pot in order to catch objects. To detect if the player has
caught or missed an object we will implement basic collision detection - note
that you will later learn how to use the \cocos{} physics engine that provides
collision detection out of the box. Whether you want to implement your own
collision detection or use the physics engine will depend a lot on the type of
game you are developing and we will discuss the advantages of both approaches
throughout this book.

When we've implemented the first control scheme we will add a second option for
players - controlling the game with the accelerometer of the device, another
common way to interact with mobile games.

As a byproduct of implementing these features we will work with translating
positions and sizes between different node spaces and the world space, so we
will be discussing that important concept throughout this chapter as well.

\section{Add the pot to the game}
The goal of our game will be to move a pot across the screen and try to catch
all the vegetables while avoiding catching inedible objects. Before we can
implement the drag and drop mechanism we need to add the pot assets to our game,
we're going to do that in the \SB{} project, open it now.

Typically we use individual \ccbfile{}s for each type of object in our game,
however for this game we need to make an exception due to the specific way in
which order \cocos{} renders our objects in the game.

\subsection{Working with the z-order}\index{Z-Order}
Throughout this book we are working with a 2D engine. In a 2D engine depth can
only be represented by certain objects being placed in front or behind of other
objects. \cocos{} uses the following criteria to decide which nodes are rendered
in front of other nodes:
\begin{enumerate}
  \item Child nodes are rendered in front of their parent nodes
  \item Siblings (nodes with the same parent) are rendered in order of their
  \inlinecode{zOrder} property; nodes with higher \inlinecode{zOrder} are
  rendered in front of nodes with a lower one
  \item If two siblings have the same \inlinecode{zOrder} the siblings are
  rendered in reverse order of how they have been added (the latest added node
  is rendered in front of all other nodes)
\end{enumerate}

As you can see from the description above the \inlinecode{zOrder} only affects
how siblings are ordered, \cocos{} currently does not have a global
\inlinecode{zOrder}. For our game we want to create the illusion of objects
dropping into a pot, we can do that using the \cocos{} Z-order as shown in
the figure below. 

\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{images/Chapter3/drawing_order.png}
		\caption{Left: Objects on different Layers, Right: How the Z-Order influences
		on which Layer a node is rendered}
\end{figure}

For this solution to work all the falling objects and the bottom and top part of
our pot need to have the same parent node, otherwise we would not be able to use
the Z-Order to place the falling objects between the two parts of the pot. 

That is the reason why we are not creating a separate \ccbfile{} for the pot
object and instead place it inside of \inlinecode{MainScene.ccb}. There would be
other ways to work around this issue but adding the pot to the Main Scene is a
good solution for this game.

\begin{details}[frametitle={Global Z-order in \cocos{}}] 
While \cocos{} does not have support for global Z-order at the moment, it is
being discussed as a potential feature for future releases. Many games run into
issues as discussed above due to the lack of this feature. You can follow the
discussion on GitHub: \url{https://github.com/cocos2d/cocos2d-swift/issues/662}.
\end{details}

\subsection{Setting up the pot assets}
Equipped with everything we need to know about Z-order let's add the pot assets
to our Main Scene in \SB{}:

\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{images/Chapter3/add_pot.png}
		\caption{Add both pot parts to the main scene}
\end{figure}

\begin{leftbar}
The assets of both pot parts have exactly the same dimensions.
 Place both of them at 50\% X position and at a Y position of 58
Create code connections for both pot parts, linked to the \textit{Document Root}. 
Name them \inlinecode{potBottom} and \inlinecode{potTop} respectively.
Publish the \SB{} project
\end{leftbar}

Next, move to the \xcode{} project to set up the code connection variables and
implement the touch handling code.

\begin{leftbar}
Open \inlinecode{SBBMainScene.m} and add instance variables for our code
connections to the implementation block of \inlinecode{SBBMainScnene}:
\begin{lstlisting}
@implementation SBBMainScene {
    __weak CCSprite *_potTop;
    __weak CCSprite *_potBottom;
}
\end{lstlisting}
\end{leftbar}

Okay, now we have the basics set up and are ready to dive into the details of
implementing a drag and drop mechanism!

\section{Implement a Drag and Drop mechanism}
For the very first project in this book we have already implemented a basic
touch mechanism. You should remember that \inlinecode{userInteractionEnabled} is
the property that activates/deactivates touch handling for a node and that
\cocos{} provides four different callbacks for different state transitions in
the lifecycle of a touch. Here's the recap:

\begin{description}
\item[touchBegan:] called when a touch begins
\item[touchMoved:] called when the touch position of a touch changes
\item[touchEnded:] called when a touch ends because the user stops touching the
screen
\item[touchCancelled:] called when a touch is cancelled because user moves touch
outside of the touch area of a node
\end{description}

Knowing that, how can we implement a drag and drop control scheme for our game?
Dragging and dropping includes three different steps:
\begin{enumerate}
  \item Pick up object
  \item Drag object
  \item Drop object
\end{enumerate}

\subsection{Picking up an Object}
In order to pick up an object we need to detect a user's touch and determine if
the touch is within the boundaries of our object, if that is the case,
we start dragging the object.

First of all, let's turn on user interaction for the \inlinecode{SBBMainScene}
class, so that we receive touch events.

\begin{leftbar}
Add the required line to the \inlinecode{onEnterTransitionDidFinish} method:
\begin{lstlisting}
- (void)onEnterTransitionDidFinish {
    [super onEnterTransitionDidFinish];
    
    self.userInteractionEnabled = YES;
    
    // spawn objects with defined frequency
    [self schedule:@selector(spawnObject) interval:kSpawnFrequency];
}
\end{lstlisting}
\end{leftbar}

Next, we need to add the touch handling method. The touch handling method will
need to check if the touch is within our pot. If that is the case, the method
will need to set a state variable that remembers that we are currently dragging
this object. If the user moves a finger across the screen and we are currently
in object dragging mode, it is important that the object follows the finger of
the user; therefore we need this state variable to remember whether we are
dragging the pot or not.

\begin{leftbar}
Add this implementation to \inlinecode{SBBMainScene.m}:
\begin{lstlisting}
- (void)touchBegan:(CCTouch *)touch withEvent:(CCTouchEvent *)event {
    // if touch is within the pot area, start dragging it
    if (CGRectContainsPoint([_potBottom boundingBox], [touch locationInNode:self])) {
        _isDraggingPot = YES;
        _dragTouchOffset = ccpSub([_potBottom anchorPointInPoints], [touch locationInNode:_potBottom]);
    }
}
\end{lstlisting}
\end{leftbar}

Let's discuss this implementation briefly. You already have seen the usage of 
\inlinecode{[touch locationInNode:self]} in the first chapter of this book,
where we briefly discussed touch handling
(\ref{Introduction_FirstTouchHandling}). This method returns the touch position
within a given node. In this specific case we are receiving the touch position
within \inlinecode{SBBMainScene}.

Next, we are using a utility function, \inlinecode{CGRectContainsPoint}, to
check if this touch is within the pot. Remember,
that \inlinecode{\_potBottom} and \inlinecode{\_potTop} are placed at exactly
the same position, so we can choose either of them for this check.
\inlinecode{CGRectContainsPoint} takes a rectangle as its first argument and a
point as its second. It returns true if the point is within the rectangle.

If the touch position is inside of the pot, we set our state variable,
\inlinecode{\_isDraggingPot}, to \inlinecode{YES}. 

There is one last line that we didn't discuss upfront:
\begin{lstlisting}
_dragTouchOffset = ccpSub([_potBottom anchorPointInPoints], [touch locationInNode:_potBottom]);
\end{lstlisting}

In order to drag an object smoothly we need to remember where we touched that
object when starting dragging. Take a look at the following diagram:
\begin{figure}[H]
		\centering
		\includegraphics[width=0.4\linewidth]{images/Chapter3/dragging_offset.png}
		\caption{\textit{Top Image:} incorrect implementation, object jumps to touch
		position. \textit{Bottom Image:} correct implementation, touch offset is
		maintained while dragging the object.}
\end{figure}
As the user moves the finger, we move the object along. However, the position of
the object is not exactly the touch position. Instead it is the touch position
\textit{plus} the touch offset determined when we started dragging. No we know
why it is important to store the touch offset!

\begin{leftbar}
To wrap up the implementation of \inlinecode{touchBegan} let's add the two
iVars we have referenced: \inlinecode{\_isDraggingPot} and
\inlinecode{\_dragTouchOffset}. Your list of iVars should now look like this:
\begin{lstlisting}
@implementation SBBMainScene {
    __weak CCSprite *_potTop;
    __weak CCSprite *_potBottom;
    __weak CCNode *_catchContainer;
    CGPoint _dragTouchOffset;
    BOOL _isDraggingPot;
}
\end{lstlisting}
\end{leftbar}