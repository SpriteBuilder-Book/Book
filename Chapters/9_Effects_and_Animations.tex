\chapter{Effects and Animations}

Up until this chapter we have built a fully functional game that could be
shipped to the App Store! This last chapter will deal with polishing the game and making
it more delightful. \SB{} and \cocos{} provide powerful, yet simple to use tools
to create visual effects and animations. In this chapter we will add light
effects and we'll use the \SB{} timeline to bring some more motion to our
gameplay.

\section{Lighting with CCEffects}
Let's start by adding some light effects to our game. Lighting effects can make
a game feel a lot more polished. Here's a comparison of what our game looks like
right now, and how it will look once we're completed this section:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/Chapter9/lighting_comparison.png}
    \caption{Unlighted scene on the left, lighted scene on the right}
    \label{lighting_example}
\end{figure}

Most game engines require developers to write \textit{shader programs} to
use visual effects such as lighting. \cocos{} provides an API called
\inlinecode{CCEffects} that implements many common visual effects, such as
lighting, refraction, blur, etc. Using CCEffects we can enhance our games
without needing to learn how to write shader programs. 

The CCEffects can even be configured with \SB{}! We can set up all of the
lighting for this game with only a handful lines of code. 

The first step of adding lighting to our game is understanding some of the
theory that goes into lighting in 2D games.

\subsection{Lighting in 2D games}
The simplest way to light a 2D scene is to use brighter and darker colors,
depending on the distance to a given light source, I'll refer to this technique
as \textit{flat lighting}. Figure \ref{lighting_example} shows flat lighting on
the background image of our game. Some areas of the background are lighter than
others. The background is the lightest around the window and the kitchen light,
the two light sources for our game.

Flat lighting comes entirely out of the box using \cocos{}. However, using flat
lighting alone doesn't create great visual effects. In 2D games lighting can be
used to give objects a 3D feel. We are going to use that technique for the pot
and the falling objects.

We will create \textit{normal maps} for each of our game objects. A normal map
is a special kind of texture that describes the 3D surface of an object. That
way the game engine can calculate how strong certain areas of a texture should
be light up by a light source. Here's what a normal map looks like:

\begin{figure}[H]
    \centering
    \includegraphics[width=180pt]{images/Chapter9/pot-bottom_NRM.png}
    \caption{The normal map for the bottom part of the pot. Each color encodes
    information about the object's surface}
\end{figure}

And here's a comparison that shows how lighting and normal maps together give
the pot a 3D feel:

\begin{figure}[H]
    \centering
    \includegraphics[width=300pt]{images/Chapter9/pot_lighting_comparison.png}
    \caption{No lighting on the left, lighting with normal map on the right}
\end{figure}

The comparison above shows that certain parts of the pot appear brighter and
shinier. \cocos{} calculates the brightness for each part of the texture based
on the normal map that we provide and the position of the light. 

Lighting and normal maps for 2D games are topics that are worth dedicating
entire books to (and there are a ton out there!) so for now we will stick with
this overview of how lighting works. Even this basic knowledge will allows us to
make the game look quite a bit better. You might wonder where the normal maps
for our textures come from. The answer is: we need to create them ourselves. 

\subsection{Creating normal maps}
There are a bunch of tools available that turn creating simple normal maps into
an easy task. For this book I've provided all of the normal maps for you, as
part of the asset pack that you downloaded at the beginning of this book.

%TODO: check crazy bump license
What if you want to create normal maps for your own game? The normal maps for
this book have been created with the tool \textit{CrazyBump}
(\url{http://www.crazybump.com/}). CrazyBump uses shape detection to guess
normal maps and the results have been great for me!

If you have complicated textures, or you need to polish the lighting effects in
your game in great detail, you might want to resort to a tool that allows you to
create a normal map manually. \textit{SpriteIlluminator}
(\url{https://www.codeandweb.com/spriteilluminator}) is a great tool for
manually creating normal maps.

Since we already have all the normal maps we need, let's dive right into \SB{}
and set up some light sources!

\subsection{Setting up lighting effects in \SB{}}
Now that we have a basic understanding of 2D lighting it's time to dive into the
CCEffects API. There are three important components that we will be using:
\begin{description}
\item[CCEffectNode] is a container for all visual effects. If
you want to apply effects to \ccsprite{}s, all of them need to be the child of a
\inlinecode{CCEffectNode}. In practice this means that you'll mostly have a
\inlinecode{CCEffectNode} as a container for your entire gameplay scene.
\item[CCEffect] represents one of the different available visual effects, e.g.
lighting, refraction, blur, etc. Currently effects can only be applied to
\ccsprite{}s. You add an effect to a sprite by instantiating a
\inlinecode{CCEffect} and assigning it to a \ccsprite{}.
\item[CCLightNode] is used in combination with the effect
\inlinecode{CCEffectLighting} to define light sources.
\end{description}

To summarize what we've discussed so far: Effects can only be applied to
\ccsprite{}s. All affected sprites need to be a child of a
\inlinecode{CCEffectNode}. Light nodes are used together with the lighting
effect and define light sources. Direction and brightness of these light nodes
is used by \cocos{} to render lighting effects.

Here's a diagram of how the components play together:

\begin{figure}[H]
    \centering
    \includegraphics[width=260pt]{images/Chapter9/effect_setup.png}
\end{figure}

We will only discuss a subset of the \inlinecode{CCEffects} API, but the good
news is that it is very easy to use and therefore can be explored without much
instruction! 

There a many simple effects that can be added with a single line of
code, such as \textit{blur} or \textit{saturation}. You can add all effects in
code or in \SB{}. You can change the relevant
properties of a \inlinecode{CCEffect} in code, that
alows you to animate effects. You can for example create
a \textit{saturation} effect that starts with full
saturation and over time reduces the saturation until
the sprite turns into a grayscale image.

Finally, \inlinecode{CCEffectStack} allows you to
combine multiple effects.

\begin{details}[frametitle={More on effects}]
If you want to learn a little bit more about effects in \cocos{} you should read
our tutorial that introduces the \inlinecode{CCEffects} 
API (\url{https://www.makeschool.com/tutorials/cocos2d-3-2-with-cceffects-is-coming}).
\end{details}

This introduction gives us enough understanding to move to \SB{} and set up our
lighting. Open the \SB{} project and select the \filemention{MainScene.ccb}
file.

\begin{leftbar}
\begin{enumerate}
  \item Drag an \textit{Effect Node} from the node library to the timeline of
  \filemention{MainScene.ccb}
  \item Use the {Shift} key to select all of the nodes that are currently added
  to Main Scene: \begin{figure}[H]
    \centering
    \includegraphics[width=200pt]{images/Chapter9/shift_select.png}
    \end{figure}
  \item Drag the selected nodes onto the \textit{Effect Node} to turn all of the nodes into children of the effect node. Your node
  hierarchy should look like this:
  \begin{figure}[H]
    \centering
    \includegraphics[width=200pt]{images/Chapter9/node_hierarchy_effect.png}
  \end{figure}
  \item Set the content size of the effect node to \textit{percentage of parent
  container} and set the size to (100\%, 100\%)
\end{enumerate}
\end{leftbar}

Now we have the \inlinecode{CCEffectNode} set up, which allows us to add visual
effects!

Next, let's look into adding the two light sources. We want the light sources to
be place on the window and above the stove. As you might remember, we are designing this game to
work on 3.5 inch iPhones, 4 inch iPhones and on iPads. 

In order to position the lights correctly for all of these device types we need
to use a little trick, simply using relative positioning with percentage values
does not work. Here's what the scene looks like on different device types using
relative positioning: 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/Chapter9/light_source_relative_position.png}
    \caption{Relative positioning results in slightly different light positions
    for each device type}
\end{figure}

We have set up the background image to be centered on all device types.
Therefore the distance of the window and the stove from the screen edges varies.
This means we cannot use the screen edges as reference points for positioning
the lights.

The center of the background image is always at exactly the same position. The
trick in this situation is to position the light sources relative to that center
position. We can do so by adding an empty \ccnode{} to the center of the scene
and adding our two light sources as children.

\begin{details}[frametitle={Previewing a scene on different device types}]
We have discussed this briefly in \ref{preview_screen_sizes}, but just as a
short reminder: \SB{} allows you to preview your scenes on different device
types. To switch between different device types, go to the \textit{Document} ->
\textit{Resolution} menu:
\begin{figure}[H]
  \centering
  \includegraphics[width=200pt]{images/Chapter9/select_resolution.png}
\end{figure}
You can also use the shortcuts displayed next to the device types!
\end{details}
Now we can start adding the center node and the two light sources.
\begin{leftbar}
First, let's add the center node.
\begin{enumerate}
  \item Drag a plain \textit{Node} from the node library and add it as a child
  of the \textit{CCEffectNode}
  \item Set its position type to be \textit{percentage of parent container}
  \item Set the position to \textit{(50\%, 50\%)}
  \item Rename the node to \textit{light-container} by selecting the node in the
  timeline and hitting the return key
\end{enumerate}
Now we can add the light source for the window. We will discuss the interesting
properties of our light sources in detail as soon as they are set up:
\begin{enumerate}
  \item Drag a \textit{Light Node} from the node library and add it as a child
  of the \textit{CCNode} that we created just now
  \item Set the position of the light to \textit{(-180, 90)}
  \item Set the \textit{Diffuse Intensity} to \textit{0.25}
  \item Set the \textit{Specular Intensity} to \textit{0.60}
  \item Set the \textit{Ambient Intensity} to \textit{0.73}
  \item Set the \textit{Cutoff Radius} to \textit{500.00}
  \item Set the \textit{Half Radius} to \textit{0.70}
  \item Set the \textit{Depth} to \textit{180}
\end{enumerate}
And finally, add the second light source:
\begin{enumerate}
  \item Drag a \textit{Light Node} from the node library and add it as a child
  of the \textit{CCNode} that we created just now
  \item Set the position of the light to \textit{(140, 40)}
  \item Set the \textit{Diffuse Intensity} to \textit{0.20}
  \item Set the \textit{Specular Intensity} to \textit{0.60}
  \item Set the \textit{Ambient Intensity} to \textit{0.00}
\end{enumerate}
\end{leftbar}

Now you should be able to switch between the different screen sizes and see that
the lights are positioned correctly all the time! Let's discuss some of the
light properties that we just set up.

\begin{description}
\item[Diffuse Intensity] the intensity of the diffused portion of the light.
Diffused light brightens nearby objects, without resulting in a
\textit{shininess} effect. Diffused light is soft, directional light.
\item[Specular Intensity] the intensity of the specular portion of the light.
Specular light is a sharp, directional light. It causes reflections on surfaces
of objects that are lit up.
\item[Ambient Intensity] the intensity of the ambient portion of the light.
Ambient light has no direction and the distance to objects in the scene is not
relevant for this kind of light. All objects in the scene are lit up by
ambient light in exactly the same way. This factor is used to set a base
brightness.
\item[Cutoff Radius] the reach of the light in points. Only nodes within the
radius of the light will be lit.
\item[Half Radius] the portion of the radius at which the intensity of the light
has fallen to half of its maximum value. You can choose a value between 0 and 1.
A smaller value will create a sharper light, a higher value will create a
smoother light.
\item[Depth] defines the distance of the light from the pane it is lighting. A
small value means that objects are lit from the side. A large value means that
the object is far away from the pane, therefore the objects are lit from the
front.
\end{description}

The last thing to note is that \cocos{} provides two different light types:
\textit{Point lights} and \textit{Directional lights}. For this game we are only
using point lights. You can change the type in the \textit{Light type} dropdown
in the property inspector. A point light only lights up objects that are within
the cutoff radius, and objects that are further away from the light source are
lit up less than closer objects. Directional lights light up all objects in the
same way. They are similar to ambient lighting, except that the light comes from
a certain direction.

\begin{details}[frametitle={More details on lighting}]
The creator of \textit{Sprite Illuminator}, one of the normal map tools
mentioned earlier, has written a nice article on lighting in \SB{} and \cocos{}
that covers many light properties in detail: \url{https://www.codeandweb.com/blog/2015/03/17/cocos2d-dynamic-lighting-tutorial
}. The source code annotations in \filemention{CCLightNode.h} of the \cocos{}
also reveal many details about the different adjustable properties.
\end{details}

At this point we have the lighting set up, but we don't see any change in our
scene. Setting up lighting is a two step process in \cocos{}. We need to define
the light sources, which we just did. Then we need to add the \textit{Lighting
effect} to sprites that shall be effected by these light sources. In this scene
we want the background image and the bottom and top part of the pot to be
affected by our light sources.

\begin{leftbar}
\begin{enumerate}
  \item Select the \textit{background} sprite from the timeline
  \item Add a lighting effect in the property inspector as following: 
  \begin{figure}[H]
    \centering
    \includegraphics[width=200pt]{images/Chapter9/add_lighting_effect.png}
  \end{figure}
  \item Select \textit{pot-top} and add a lighting effect in the same way you
  added it to the background
  \item Adjust the \textit{shininess} of this lighting effect to \textit{0.3}
  \item Select \textit{pot-bottom} and add a lighting effect
  \item Adjust the \textit{shininess} to \textit{0.3} 
\end{enumerate}
\end{leftbar}

Now you should see the lighting taking effect! The last thing we need to do is
add our normal maps.

\subsection{Assigning normal maps in \SB{}}
Now that our light sources and lighting effects are set up, let's assign the
normal maps to our sprites so that we get more detailed lighting. For the \textit{pot-top}
and \textit{pot-bottom} sprite, we can set up the normal map in \SB{}. The
falling objects are spawned dynamically in code, we will look at how to set up
their normal maps in the next section.

Adding normal maps to sprites is very simple in \SB{}. In the property
insepctor of a \ccsprite{} there's a separate dropdown below the \textit{Sprite
frame} dropdown that allows us to assign a normal map:

\begin{figure}[H]
  \centering
  \includegraphics[width=200pt]{images/Chapter9/select_normal_map.png}
\end{figure}

\begin{leftbar}
\begin{enumerate}
  \item Select \textit{pot-top} in the timeline 
  \item Set the normal map to \filemention{assets\/pot-top\_NRM.png}
  \item Select \textit{pot-bottom} in the timeline
  \item Set the normal map to \filemention{assets\/pot-bottom\_NRM.png}
\end{enumerate}
\end{leftbar}

Great! Now you should see a nicely lit scene, with subtle reflections on the
pot:

\begin{figure}[H]
  \centering
  \includegraphics[width=350pt]{images/Chapter9/lighting_finished.png}
\end{figure}

Note that the preview of the lighting effects in \SB{} currently don't match the
lighting effects on the simulator or device exactly. To get a good understanding
of how your lighting effects are working you'll need to run your game from
\xcode{}.

Now all that's left in terms of lighting is assigning normal maps to
our falling objects as well!

\begin{details}[frametitle={Testing lighting effects on the simulator}]
In case you've been curious and have tried running the current version of the
project, you might have realized that the performance in the simulator is
extremely poor. The reason is that the iOS simulator doesn't use your computers
GPU for all OpenGL features, but instead simulates many of them in software,
which in many cases can be extremely slow. When working with CCEffects, I highly
recommend testing your game on an actual device, even though that means that
you're required to purchase an Apple Developer license.
\end{details}

\subsection{Assigning normal maps in code}
As mentioned earlier, the falling objects are spawned dynamically in code,
therefore we cannot assign the normal maps in \SB{}. However, adding normal
maps in code is pretty simple. Additionally we will also need to look into
adding the lighting effect to all falling objects in code, so that they are
affected by our two light sources.


